Guillaume St-Pierre
101066038

# Assignment 3

## 1. Give each asteroid a turning rate and an orientation. Have them tumble (rotate about their own centre) as they move through space.

To make this happen, I added some generic TORSO code to the basic GameObject class in GameObject.ccp. Now, each GameObject will have two new transform variables, a vector called scale and a float called rotation.
The generic code will use the TORSO order we learned in class to add rotation based on the rotation (It was based off the velocity angle before, the two are now separate) and a scale based on the scale.

## 2. Center the screen on the player. (How can you do this? It will require a change to the View transformation in the shader based on the player position.)

This can be found on main.cpp, line 282. We send the view matrix centered on the player to the shader so it can multiply the local transformations with the local ones.

## 3. Allow the player to zoom in and out, say by pressing Z and X. This will mean applying a Scale to everything; I suggest changing the View transformation.

The controls method in main.cpp has two new conditions. Pressing Z will increase the global variable called window_camera_zoom and pressing X will decrease it, effectively zooming out and in respectively. This variable is used in the original scale of the viewMatrix to scale depending on the zoom.

## 4. Add shields orbiting the player (use the orb icon). When a player hits an asteroid, one shield is lost and the asteroid is destroyed. If there is a collision and there are no shields left, game over. Use an Orbit transformation for the shield movement. Make sure the shield orbs are reasonably spaced out (how?).

This code is found inside the PlayerGameObject class. I added a few new instance variables to the class, namely:
- shieldTexture contains the orb texture
- rotationCurve is a programmatic curve for rotating the shields around the orbit of the ship.
- invulnerabilityTime is a timer that makes sure the playe rhas some invulnerability time before being hit again.

The constroctor has been updated to add all those variables and set them when creating a new player.

The rotationCurve is generated by a new method called generateRotationCurve which is defined on line 27 of the PlayerGameObject.ccp file. This method generates the curve using the number of shileds as steps.
The update method will then update the curve positions so the orb rotates around the ship.

Finally, the render method has a loop starting at line 126 that generates the shields based on their programmatic curve and apply transform on them so they orbit properly and are scaled as expected.

## 5. The most challenging part: turn the player spaceship into a tank with independently controllable turret. The tank body and turret should be linked, obviously, but the turret can rotate independently around its joint. You'll need an Orbit -- simply rotating the turret will rotate it around the sprite's centre, which is not the joint. Add the needed properties to the player object, obviously. (What do you need to do with the shader to get it to render two sprites?)

I reused the base code I added for the shields to create the turret, but I had to apply a small offset so the turret is rotate along its joint using the y axis. The code for this can be found on line 77 of PlayerGameObject.cpp, it is drawn first as OpenGL use the order of drawing as the base Z-index for entities.

Additionally, the PlayerGameObject class also has a new transformation variable for the turret rotation with getters and setter to modify it so it can rotate independently of the ship's rotation.

## 5b. Add controls to let the player rotate the turret independently.

The controls method has two new conditions, one for the left key and the other for the right key. Both keys will update the turret rotation on the PlayerGameObject using a method very similar to the angle update from the same method. This code can be found on line 248 of main.cpp.

## 5c. Change the bullets so that they are fired from the turret rather than from the forward direction of the player.

This only required a small change to the code on line 265 of main.cpp, creating a bullet is  now done with the player's turret rotation instead of its angle.

# Assignment 2

## 2. Give the player object asteroids-like controls: the ability to turn; the ability to accelerate in the current facing direction. You will have to add a "facing" or "bearing" variable to the player object, just as you did in the first lab. 

This was the code for assignment 1, it can be found inside the main.ccp file and GameObject.ccp file.
The `controls` function in main.cpp creates a forward or backwards vector on teh press of W and S respectively and will increase or decrease the angle with A and D.
The `update` method in GameObject.ccp takes care of rotating the forward vector from main.cpp using the angle and the vector rotation formula.

## 2b. Optionally, change the player sprite to a spaceship. Definitely make sure you can tell from the sprite's appearance which way it is facing.

You can see the new sprites in game, they are loaded from the `setallTexture` function in main.cpp.
The `render` method in GameObject.cpp rotate the sprite using the rotate function from glm.

## 3. Give the player the ability to fire. On keypress, add a bullet object which will move forward with a fast speed along the player's current forward direction. Give the bullet objects a suitable sprite. You will want to add a cooldown to the player's shooting (how?) so that the player doesn't accidentally fire several bullets with every keypress.

The `controls` function in main.cpp will spawn a bullet when pressed.

A new class extending the GameObject class has been created named `BulletGameObject`. This class overrides the `update` and `render` methods on the base class. The PlayerGameObject also now sets some counters to slow down shooting.
The `render` method on the BulletGameObject class rewrites the code from the base class to also include a scale matrix that resizes the bullet to be smaller.

Finally, the PlayerGameObject defines two methods: `shoot` will trigger a shot on the player game object, resetting the counter for the next shot. `isShotReady` is a getter that check if the counter is bellow zero (It wait for up to half a second).
The `update` method on PlayerGameObject now removes the delta time from the counter so the wait time is tied to the clock and not the framerate.

## 3b. Give the bullets a limited lifespan; they should expire after a certain time passes, so that they don't keep on going forever off the screen and wasting time and memory. 

I added a `dirty flag on the base `GameObject` class that can be set to trigger a despawn of the objects. When the bullet gets out of bounds, as calculated in the `gameLoop` function in main.cpp, it is set as dirty and is cleanup up later in `gameLoop`.

## 4. Add asteroid objects to the game. These should be distributed around the screen, given random positions (if you are clever) or hard-coded positions (if you are hardworking but not necessarily clever) in the game setup. Optionally, give them a suitable sprite.

A new function in main.ccp named `spawnAsteroids` has been added. It is called in `setup` to randomly spawn 5 asteroids around the boundaries of the screen. The asteroids will roughly target the middle of the screen with a random angle.

## 5. Add collisions between bullets and asteroids. A collision should destroy both the bullet and asteroid. (How can you tell if a collision is between a bullet and an asteroid or between two bullets, or two asteroids?)

The `GameObject` class now defines a `colidesWith` method that check all the other game objects to see if a collision has happened. This allows the entities who want to check for collision to get which element they are colliding with.
To enable this, the `update` method on `GameObject` now takes all the entities as a second parameter.

The `BulletGameObject` overrides the `update` method to check if it collides with an asteroid. We use type casting to check if the collided element is indeed an asteroid and set both elements as dirty if a collision happened. The code described in # 3b takes care of the despawing when an entity is dirty.

## 6. Add collisions between the player and asteroids. A collision should end the game.

This works exactly like #5., but the code for the collision is now in the overridden `update` method in `PlayerGameObject`.

## 7. Give the asteroids some simple behaviour. At minimum, make them move in a straight line. You can get them to do something else if you like. Use incremental motion.

Described in #4

## 7b. Optionally, spawn more asteroids when the original asteroids are all gone.

The `spawnAsteroids` method loops in the gameObjects vector to check how many asteroids exist. If less than five exist, it will spawn more to get it up to 5. Using a counter in main.ccp that waits for a second a half updated in the gameLoop using the delta time, we spawn more asteroids when needed by calling the `spawnAsteroids` method again.

## 7c. You will notice that if you leave things alone, the asteroids will escape from the screen and be difficult to hunt down (since the player will have to leave the screen too). Optionally, add something to fix this. The original Asteroids game had objects reappear at the other side of the screen when they left from one side; you could do this, or maybe you have other ideas that would work.

This is handled using the boundaries collision in #3b. When an asteroid despawn, it will be spawned again when the counter for waiting to spawn asteroids in main.cpp is lower than 0.

## 8. Give the player limited ammunition, say 5 shots. Ammunition should gradually replenish over time. Show the remaining ammunition with bullet icons at the edge of the screen, e.g., 5 bullet sprites if the player has 5 bullets currently. Probably these should not be in the game object vector with all the other actual game entities, since you will not want to do collision detection or any game logic with them: they are strictly a UI element.

Added one more counter in `PlayerGameObject` to wait 1 second _after the last shoot has been fired_ to replenish 1 bullet. this is all managed in the `update` method of `PlayerGameObject` as well as the `shoot` method. 
Using the `hasAmmunition` getter, we can prevent shooting where there is no ammunition remaining.

Finally, using the `getAmmunition` getter in main.cpp, we can render the number of bullets in the `gameLoop` function. We create a reused object in the `setup` method that represents the bullet for the interface. We then loop from 0 to the ammunition count and render that bullet again and again with some offset to represent the interface.

## 9. You have the bare bones of a game at this point. For up to +10%, add some additional features you are interested in, such as powerups, explosions, enemies that shoot at the player, a "game over" screen, or anything else you can think of.

Implemented a system to move the ship on the other side of the screen instead of despawning it when it reaches the boundaries of the screen. This method is generic to all elements and could be applied to asteroids if we wanted.

# Assignment 1

## Added
- Added collision checking with the outside boundaries of the game view so entities can be despawned.
- Added the ability to fire bullets from the player object. Bullets still need to be scaled down.
- Added a color to game objects than can be passed to the shaders. This color will be merge with the texture color to allow creating multiple sprites from the same base texture.
- Added an offest vector to game objects which the shader will use to offset the position of the entity. This could be used to make the object shake when hit for example.
- Added a rotation system to the sprit will rotate depending on the angle of movement.

## Changed
- Changed the main game loop to loop on entities using an iterator rather than an integer.
- Changed the controls to make controlling the player feel more like an helicopter. This new system make it so you can change the angle of movement using the S and D keys, accelerate with the W key and brake using the S key.
